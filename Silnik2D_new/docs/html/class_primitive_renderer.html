<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Silnik2D: PrimitiveRenderer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Silnik2D
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="class_primitive_renderer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">PrimitiveRenderer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Klasa do rysowania prymitywów graficznych w oknie SFML.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_primitive_renderer_8h_source.html">PrimitiveRenderer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a579f99c1724b09b26c898a25ad5ff70b" id="r_a579f99c1724b09b26c898a25ad5ff70b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a579f99c1724b09b26c898a25ad5ff70b">PrimitiveRenderer</a> ()</td></tr>
<tr class="memdesc:a579f99c1724b09b26c898a25ad5ff70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Konstruktor klasy <a class="el" href="class_primitive_renderer.html" title="Klasa do rysowania prymitywów graficznych w oknie SFML.">PrimitiveRenderer</a>.  <br /></td></tr>
<tr class="separator:a579f99c1724b09b26c898a25ad5ff70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91fbc53cf97e40dc3e8005533563ae4" id="r_ac91fbc53cf97e40dc3e8005533563ae4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac91fbc53cf97e40dc3e8005533563ae4">drawLineIncremental</a> (sf::RenderTarget &amp;window, const <a class="el" href="class_point2_d.html">Point2D</a> &amp;p1, const <a class="el" href="class_point2_d.html">Point2D</a> &amp;p2, sf::Color color)</td></tr>
<tr class="memdesc:ac91fbc53cf97e40dc3e8005533563ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rysuje liniê metod¹ przyrostow¹.  <br /></td></tr>
<tr class="separator:ac91fbc53cf97e40dc3e8005533563ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4db6ccc3a13a45faac4ccd03be56598" id="r_aa4db6ccc3a13a45faac4ccd03be56598"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4db6ccc3a13a45faac4ccd03be56598">drawPolyline</a> (sf::RenderWindow &amp;window, const std::vector&lt; <a class="el" href="class_point2_d.html">Point2D</a> &gt; &amp;points, sf::Color color, bool closed=false)</td></tr>
<tr class="memdesc:aa4db6ccc3a13a45faac4ccd03be56598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rysuje wieloliniê (polyline).  <br /></td></tr>
<tr class="separator:aa4db6ccc3a13a45faac4ccd03be56598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77cdbaff8f382917432a443a9a9a5e7f" id="r_a77cdbaff8f382917432a443a9a9a5e7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77cdbaff8f382917432a443a9a9a5e7f">drawLineBasic</a> (sf::RenderWindow &amp;window, const <a class="el" href="class_point2_d.html">Point2D</a> &amp;p1, const <a class="el" href="class_point2_d.html">Point2D</a> &amp;p2, sf::Color color)</td></tr>
<tr class="memdesc:a77cdbaff8f382917432a443a9a9a5e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rysuje liniê za pomoc¹ algorytmu podstawowego.  <br /></td></tr>
<tr class="separator:a77cdbaff8f382917432a443a9a9a5e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75177202b249f154f5cec46adf51f50c" id="r_a75177202b249f154f5cec46adf51f50c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75177202b249f154f5cec46adf51f50c">drawCircle</a> (sf::RenderWindow &amp;window, const <a class="el" href="class_point2_d.html">Point2D</a> &amp;center, int radius, sf::Color color)</td></tr>
<tr class="memdesc:a75177202b249f154f5cec46adf51f50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rysuje okr¹g.  <br /></td></tr>
<tr class="separator:a75177202b249f154f5cec46adf51f50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6b6f15ec1df730599da52d58450f55" id="r_a9f6b6f15ec1df730599da52d58450f55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f6b6f15ec1df730599da52d58450f55">drawEllipse</a> (sf::RenderWindow &amp;window, const <a class="el" href="class_point2_d.html">Point2D</a> &amp;center, int radiusX, int radiusY, sf::Color color)</td></tr>
<tr class="memdesc:a9f6b6f15ec1df730599da52d58450f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rysuje elipsê.  <br /></td></tr>
<tr class="separator:a9f6b6f15ec1df730599da52d58450f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115646f1290e839e5e7097e4c76dff50" id="r_a115646f1290e839e5e7097e4c76dff50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a115646f1290e839e5e7097e4c76dff50">drawPolygon</a> (sf::RenderWindow &amp;window, const std::vector&lt; <a class="el" href="class_point2_d.html">Point2D</a> &gt; &amp;points, sf::Color color, bool closed=true)</td></tr>
<tr class="memdesc:a115646f1290e839e5e7097e4c76dff50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rysuje wielok¹t.  <br /></td></tr>
<tr class="separator:a115646f1290e839e5e7097e4c76dff50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a20c637c52e118ea7316d1fa96bc752" id="r_a0a20c637c52e118ea7316d1fa96bc752"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a20c637c52e118ea7316d1fa96bc752">drawFilledCircle</a> (sf::RenderWindow &amp;window, const <a class="el" href="class_point2_d.html">Point2D</a> &amp;center, int radius, sf::Color color)</td></tr>
<tr class="memdesc:a0a20c637c52e118ea7316d1fa96bc752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rysuje wype³niony okr¹g.  <br /></td></tr>
<tr class="separator:a0a20c637c52e118ea7316d1fa96bc752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50aa481e609a5eb77af5a18b38d8c2d" id="r_ad50aa481e609a5eb77af5a18b38d8c2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad50aa481e609a5eb77af5a18b38d8c2d">borderFill</a> (sf::RenderTexture &amp;renderTexture, int startX, int startY, sf::Color fillColor, sf::Color boundaryColor)</td></tr>
<tr class="memdesc:ad50aa481e609a5eb77af5a18b38d8c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wype³nianie obszaru metod¹ krawêdziow¹ (border fill).  <br /></td></tr>
<tr class="separator:ad50aa481e609a5eb77af5a18b38d8c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f37978f4a14baa3c20564a59bc9c502" id="r_a8f37978f4a14baa3c20564a59bc9c502"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f37978f4a14baa3c20564a59bc9c502">floodFill</a> (sf::RenderTexture &amp;renderTexture, int startX, int startY, sf::Color fillColor, sf::Color oldColor)</td></tr>
<tr class="memdesc:a8f37978f4a14baa3c20564a59bc9c502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wype³nianie obszaru metod¹ zalewania (flood fill).  <br /></td></tr>
<tr class="separator:a8f37978f4a14baa3c20564a59bc9c502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bca5df32993ece0b27a64da40bf8267" id="r_a6bca5df32993ece0b27a64da40bf8267"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bca5df32993ece0b27a64da40bf8267">drawFilledPolygon</a> (sf::RenderWindow &amp;window, const std::vector&lt; <a class="el" href="class_point2_d.html">Point2D</a> &gt; &amp;points, sf::Color fillColor)</td></tr>
<tr class="memdesc:a6bca5df32993ece0b27a64da40bf8267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rysuje wype³niony wielok¹t.  <br /></td></tr>
<tr class="separator:a6bca5df32993ece0b27a64da40bf8267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c5460f4a0752e97cff451065c2c0ba" id="r_ac8c5460f4a0752e97cff451065c2c0ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8c5460f4a0752e97cff451065c2c0ba">drawBorderFilledPolygon</a> (sf::RenderWindow &amp;window, const std::vector&lt; <a class="el" href="class_point2_d.html">Point2D</a> &gt; &amp;points, sf::Color fillColor)</td></tr>
<tr class="memdesc:ac8c5460f4a0752e97cff451065c2c0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rysuje wielok¹t z wype³nieniem i obrysem.  <br /></td></tr>
<tr class="separator:ac8c5460f4a0752e97cff451065c2c0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6365b1815406bf92f0e922c5672f77" id="r_afd6365b1815406bf92f0e922c5672f77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd6365b1815406bf92f0e922c5672f77">drawFloodFilledPolygon</a> (sf::RenderWindow &amp;window, const std::vector&lt; <a class="el" href="class_point2_d.html">Point2D</a> &gt; &amp;points, sf::Color fillColor)</td></tr>
<tr class="memdesc:afd6365b1815406bf92f0e922c5672f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rysuje wielok¹t wype³niony metod¹ zalewania (flood fill).  <br /></td></tr>
<tr class="separator:afd6365b1815406bf92f0e922c5672f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a7a9f1597728ab277ba4331fa40acbcdd" id="r_a7a9f1597728ab277ba4331fa40acbcdd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a9f1597728ab277ba4331fa40acbcdd">checkForIntersections</a> (const std::vector&lt; <a class="el" href="class_line_segment.html">LineSegment</a> &gt; &amp;segments)</td></tr>
<tr class="memdesc:a7a9f1597728ab277ba4331fa40acbcdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sprawdza, czy istniej¹ przeciêcia miêdzy segmentami.  <br /></td></tr>
<tr class="separator:a7a9f1597728ab277ba4331fa40acbcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb17ce7a98e8de39fe6303cd017c3cb" id="r_a0fb17ce7a98e8de39fe6303cd017c3cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fb17ce7a98e8de39fe6303cd017c3cb">doIntersect</a> (const <a class="el" href="class_point2_d.html">Point2D</a> &amp;p1, const <a class="el" href="class_point2_d.html">Point2D</a> &amp;q1, const <a class="el" href="class_point2_d.html">Point2D</a> &amp;p2, const <a class="el" href="class_point2_d.html">Point2D</a> &amp;q2)</td></tr>
<tr class="memdesc:a0fb17ce7a98e8de39fe6303cd017c3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sprawdza, czy dwa odcinki przecinaj¹ siê.  <br /></td></tr>
<tr class="separator:a0fb17ce7a98e8de39fe6303cd017c3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Klasa do rysowania prymitywów graficznych w oknie SFML. </p>
<p>Oferuje zestaw metod do rysowania linii, wielok¹tów, okrêgów i elips, zarówno wype³nionych, jak i nie. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a579f99c1724b09b26c898a25ad5ff70b" name="a579f99c1724b09b26c898a25ad5ff70b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579f99c1724b09b26c898a25ad5ff70b">&#9670;&#160;</a></span>PrimitiveRenderer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PrimitiveRenderer::PrimitiveRenderer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Konstruktor klasy <a class="el" href="class_primitive_renderer.html" title="Klasa do rysowania prymitywów graficznych w oknie SFML.">PrimitiveRenderer</a>. </p>
<p>Konstruktor klasy <a class="el" href="class_primitive_renderer.html" title="Klasa do rysowania prymitywów graficznych w oknie SFML.">PrimitiveRenderer</a>. Inicjalizuje obiekt i wyÅ›wietla komunikat w konsoli. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad50aa481e609a5eb77af5a18b38d8c2d" name="ad50aa481e609a5eb77af5a18b38d8c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50aa481e609a5eb77af5a18b38d8c2d">&#9670;&#160;</a></span>borderFill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrimitiveRenderer::borderFill </td>
          <td>(</td>
          <td class="paramtype">sf::RenderTexture &amp;</td>          <td class="paramname"><span class="paramname"><em>renderTexture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startY</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Color</td>          <td class="paramname"><span class="paramname"><em>fillColor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Color</td>          <td class="paramname"><span class="paramname"><em>boundaryColor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wype³nianie obszaru metod¹ krawêdziow¹ (border fill). </p>
<p>WypeÅ‚nia obszar kolorem do granicy okreÅ›lonej kolorem granicznym.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderTexture</td><td>Tekstura do renderowania. </td></tr>
    <tr><td class="paramname">startX</td><td>Pozycja pocz¹tkowa w osi X. </td></tr>
    <tr><td class="paramname">startY</td><td>Pozycja pocz¹tkowa w osi Y. </td></tr>
    <tr><td class="paramname">fillColor</td><td>Kolor wype³nienia. </td></tr>
    <tr><td class="paramname">boundaryColor</td><td>Kolor krawêdzi.</td></tr>
  </table>
  </dd>
</dl>
<p>Funkcja wykonuje algorytm wypeÅ‚niania obszaru (ang. boundary fill), zaczynajÄ…c od punktu startowego. WypeÅ‚nia wszystkie piksele w zadanym obszarze, ktÃ³re nie sÄ… w kolorze granicznym i nie sÄ… juÅ¼ wypeÅ‚nione kolorem wypeÅ‚nienia.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderTexture</td><td>Obiekt <code>sf::RenderTexture</code>, w ktÃ³rym przeprowadzane jest wypeÅ‚nianie. </td></tr>
    <tr><td class="paramname">startX</td><td>WspÃ³Å‚rzÄ™dna X punktu poczÄ…tkowego. </td></tr>
    <tr><td class="paramname">startY</td><td>WspÃ³Å‚rzÄ™dna Y punktu poczÄ…tkowego. </td></tr>
    <tr><td class="paramname">fillColor</td><td>Kolor, ktÃ³rym wypeÅ‚niany jest obszar. </td></tr>
    <tr><td class="paramname">boundaryColor</td><td>Kolor graniczny definiujÄ…cy zakres wypeÅ‚nienia.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Funkcja zakÅ‚ada, Å¼e punkt poczÄ…tkowy znajduje siÄ™ wewnÄ…trz obszaru do wypeÅ‚nienia oraz Å¼e kolory <code>fillColor</code> i <code>boundaryColor</code> sÄ… rÃ³Å¼ne. </dd></dl>

</div>
</div>
<a id="a7a9f1597728ab277ba4331fa40acbcdd" name="a7a9f1597728ab277ba4331fa40acbcdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9f1597728ab277ba4331fa40acbcdd">&#9670;&#160;</a></span>checkForIntersections()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PrimitiveRenderer::checkForIntersections </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_line_segment.html">LineSegment</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>segments</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sprawdza, czy istniej¹ przeciêcia miêdzy segmentami. </p>
<p>Sprawdza, czy w podanym wektorze odcinkÃ³w wystÄ™pujÄ… przeciÄ™cia.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segments</td><td>Wektor segmentów do sprawdzenia. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, jeœli istniej¹ przeciêcia; false w przeciwnym razie.</dd></dl>
<p>Funkcja analizuje wszystkie pary odcinkÃ³w w podanym wektorze i sprawdza, czy jakiekolwiek dwa odcinki siÄ™ przecinajÄ…. Wykorzystuje funkcjÄ™ <code>doIntersect</code> do wykrycia przeciÄ™Ä‡.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segments</td><td>Wektor odcinkÃ³w do sprawdzenia.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true JeÅ›li co najmniej dwa odcinki siÄ™ przecinajÄ…. </dd>
<dd>
false JeÅ›li Å¼adne odcinki siÄ™ nie przecinajÄ….</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0fb17ce7a98e8de39fe6303cd017c3cb" title="Sprawdza, czy dwa odcinki przecinaj¹ siê.">doIntersect</a> </dd></dl>

</div>
</div>
<a id="a0fb17ce7a98e8de39fe6303cd017c3cb" name="a0fb17ce7a98e8de39fe6303cd017c3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb17ce7a98e8de39fe6303cd017c3cb">&#9670;&#160;</a></span>doIntersect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PrimitiveRenderer::doIntersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>q2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sprawdza, czy dwa odcinki przecinaj¹ siê. </p>
<p>Sprawdza, czy dwa odcinki siÄ™ przecinajÄ….</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>Punkt pocz¹tkowy pierwszego odcinka. </td></tr>
    <tr><td class="paramname">q1</td><td>Punkt koñcowy pierwszego odcinka. </td></tr>
    <tr><td class="paramname">p2</td><td>Punkt pocz¹tkowy drugiego odcinka. </td></tr>
    <tr><td class="paramname">q2</td><td>Punkt koñcowy drugiego odcinka. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, jeœli odcinki przecinaj¹ siê; false w przeciwnym razie.</dd></dl>
<p>Funkcja okreÅ›la, czy dwa odcinki, zdefiniowane przez swoje koÅ„cowe punkty, przecinajÄ… siÄ™. Wykorzystuje iloczyn wektorowy do okreÅ›lenia wzajemnego poÅ‚oÅ¼enia punktÃ³w.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>PoczÄ…tek pierwszego odcinka. </td></tr>
    <tr><td class="paramname">q1</td><td>Koniec pierwszego odcinka. </td></tr>
    <tr><td class="paramname">p2</td><td>PoczÄ…tek drugiego odcinka. </td></tr>
    <tr><td class="paramname">q2</td><td>Koniec drugiego odcinka.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true JeÅ›li odcinki siÄ™ przecinajÄ…. </dd>
<dd>
false JeÅ›li odcinki siÄ™ nie przecinajÄ….</dd></dl>
<dl class="section note"><dt>Note</dt><dd>ZakÅ‚ada, Å¼e odcinki sÄ… ograniczone (nie sÄ… przedÅ‚uÅ¼one do prostych). </dd></dl>

</div>
</div>
<a id="ac8c5460f4a0752e97cff451065c2c0ba" name="ac8c5460f4a0752e97cff451065c2c0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c5460f4a0752e97cff451065c2c0ba">&#9670;&#160;</a></span>drawBorderFilledPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrimitiveRenderer::drawBorderFilledPolygon </td>
          <td>(</td>
          <td class="paramtype">sf::RenderWindow &amp;</td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_point2_d.html">Point2D</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Color</td>          <td class="paramname"><span class="paramname"><em>fillColor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rysuje wielok¹t z wype³nieniem i obrysem. </p>
<p>Rysuje wielokÄ…t z wypeÅ‚nieniem, zachowujÄ…c granicÄ™.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Obiekt do rysowania (np. sf::RenderWindow). </td></tr>
    <tr><td class="paramname">points</td><td>Wektor punktów definiuj¹cych wielok¹t. </td></tr>
    <tr><td class="paramname">fillColor</td><td>Kolor wype³nienia.</td></tr>
  </table>
  </dd>
</dl>
<p>Funkcja rysuje wielokÄ…t okreÅ›lony przez wektor punktÃ³w, z wypeÅ‚nieniem w zadanym kolorze. Granice wielokÄ…ta sÄ… rysowane na podstawie jego wierzchoÅ‚kÃ³w, a nastÄ™pnie obszar wewnÄ™trzny wypeÅ‚niany jest w okreÅ›lonym kolorze, uÅ¼ywajÄ…c algorytmu wypeÅ‚niania obszaru.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Okno, na ktÃ³rym bÄ™dzie rysowany wielokÄ…t. </td></tr>
    <tr><td class="paramname">points</td><td>Wektor punktÃ³w, ktÃ³re definiujÄ… wierzchoÅ‚ki wielokÄ…ta. </td></tr>
    <tr><td class="paramname">fillColor</td><td>Kolor wypeÅ‚nienia obszaru wewnÄ™trznego wielokÄ…ta.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Funkcja sprawdza, czy liczba punktÃ³w jest wystarczajÄ…ca do narysowania wielokÄ…ta (musi ich byÄ‡ co najmniej 3). JeÅ›li liczba punktÃ³w jest mniejsza, funkcja nie wykonuje rysowania. </dd>
<dd>
Funkcja tworzy tymczasowy obiekt <code>RenderTexture</code>, aby wykonaÄ‡ operacjÄ™ wypeÅ‚nienia, a nastÄ™pnie rysuje gotowy obraz w oknie. </dd></dl>

</div>
</div>
<a id="a75177202b249f154f5cec46adf51f50c" name="a75177202b249f154f5cec46adf51f50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75177202b249f154f5cec46adf51f50c">&#9670;&#160;</a></span>drawCircle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrimitiveRenderer::drawCircle </td>
          <td>(</td>
          <td class="paramtype">sf::RenderWindow &amp;</td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Color</td>          <td class="paramname"><span class="paramname"><em>color</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rysuje okr¹g. </p>
<p>Rysuje okrÄ…g za pomocÄ… algorytmu rysowania okrÄ™gÃ³w.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Obiekt do rysowania (np. sf::RenderWindow). </td></tr>
    <tr><td class="paramname">center</td><td>Œrodek okrêgu. </td></tr>
    <tr><td class="paramname">radius</td><td>Promieñ okrêgu. </td></tr>
    <tr><td class="paramname">color</td><td>Kolor okrêgu.</td></tr>
    <tr><td class="paramname">window</td><td>Obiekt okna renderowania. </td></tr>
    <tr><td class="paramname">center</td><td>Åšrodek okrÄ™gu. </td></tr>
    <tr><td class="paramname">radius</td><td>PromieÅ„ okrÄ™gu. </td></tr>
    <tr><td class="paramname">color</td><td>Kolor okrÄ™gu. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f6b6f15ec1df730599da52d58450f55" name="a9f6b6f15ec1df730599da52d58450f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6b6f15ec1df730599da52d58450f55">&#9670;&#160;</a></span>drawEllipse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrimitiveRenderer::drawEllipse </td>
          <td>(</td>
          <td class="paramtype">sf::RenderWindow &amp;</td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>radiusX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>radiusY</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Color</td>          <td class="paramname"><span class="paramname"><em>color</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rysuje elipsê. </p>
<p>Rysuje elipsÄ™.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Obiekt do rysowania (np. sf::RenderWindow). </td></tr>
    <tr><td class="paramname">center</td><td>Œrodek elipsy. </td></tr>
    <tr><td class="paramname">radiusX</td><td>Promieñ w osi X. </td></tr>
    <tr><td class="paramname">radiusY</td><td>Promieñ w osi Y. </td></tr>
    <tr><td class="paramname">color</td><td>Kolor elipsy.</td></tr>
    <tr><td class="paramname">window</td><td>Obiekt okna renderowania. </td></tr>
    <tr><td class="paramname">center</td><td>Åšrodek elipsy. </td></tr>
    <tr><td class="paramname">rx</td><td>PromieÅ„ poziomy (wzdÅ‚uÅ¼ osi X). </td></tr>
    <tr><td class="paramname">ry</td><td>PromieÅ„ pionowy (wzdÅ‚uÅ¼ osi Y). </td></tr>
    <tr><td class="paramname">color</td><td>Kolor elipsy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a20c637c52e118ea7316d1fa96bc752" name="a0a20c637c52e118ea7316d1fa96bc752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a20c637c52e118ea7316d1fa96bc752">&#9670;&#160;</a></span>drawFilledCircle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrimitiveRenderer::drawFilledCircle </td>
          <td>(</td>
          <td class="paramtype">sf::RenderWindow &amp;</td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Color</td>          <td class="paramname"><span class="paramname"><em>color</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rysuje wype³niony okr¹g. </p>
<p>Rysuje okrÄ…g z wypeÅ‚nieniem.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Obiekt do rysowania (np. sf::RenderWindow). </td></tr>
    <tr><td class="paramname">center</td><td>Œrodek okrêgu. </td></tr>
    <tr><td class="paramname">radius</td><td>Promieñ okrêgu. </td></tr>
    <tr><td class="paramname">color</td><td>Kolor wype³nienia.</td></tr>
    <tr><td class="paramname">window</td><td>Obiekt okna renderowania. </td></tr>
    <tr><td class="paramname">center</td><td>Åšrodek okrÄ™gu. </td></tr>
    <tr><td class="paramname">radius</td><td>PromieÅ„ okrÄ™gu. </td></tr>
    <tr><td class="paramname">color</td><td>Kolor okrÄ™gu. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bca5df32993ece0b27a64da40bf8267" name="a6bca5df32993ece0b27a64da40bf8267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bca5df32993ece0b27a64da40bf8267">&#9670;&#160;</a></span>drawFilledPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrimitiveRenderer::drawFilledPolygon </td>
          <td>(</td>
          <td class="paramtype">sf::RenderWindow &amp;</td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_point2_d.html">Point2D</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Color</td>          <td class="paramname"><span class="paramname"><em>fillColor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rysuje wype³niony wielok¹t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Obiekt do rysowania (np. sf::RenderWindow). </td></tr>
    <tr><td class="paramname">points</td><td>Wektor punktów definiuj¹cych wielok¹t. </td></tr>
    <tr><td class="paramname">fillColor</td><td>Kolor wype³nienia. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd6365b1815406bf92f0e922c5672f77" name="afd6365b1815406bf92f0e922c5672f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6365b1815406bf92f0e922c5672f77">&#9670;&#160;</a></span>drawFloodFilledPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrimitiveRenderer::drawFloodFilledPolygon </td>
          <td>(</td>
          <td class="paramtype">sf::RenderWindow &amp;</td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_point2_d.html">Point2D</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Color</td>          <td class="paramname"><span class="paramname"><em>fillColor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rysuje wielok¹t wype³niony metod¹ zalewania (flood fill). </p>
<p>Rysuje wypeÅ‚niony wielokÄ…t na podstawie podanych punktÃ³w.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Obiekt do rysowania (np. sf::RenderWindow). </td></tr>
    <tr><td class="paramname">points</td><td>Wektor punktów definiuj¹cych wielok¹t. </td></tr>
    <tr><td class="paramname">fillColor</td><td>Kolor wype³nienia.</td></tr>
  </table>
  </dd>
</dl>
<p>Funkcja rysuje wypeÅ‚niony wielokÄ…t na podstawie wierzchoÅ‚kÃ³w zdefiniowanych w wektorze punktÃ³w. WypeÅ‚nienie jest wykonywane na podstawie algorytmu skanowania poziomych linii, w ktÃ³rym obliczane sÄ… punkty przeciÄ™cia krawÄ™dzi wielokÄ…ta z poziomymi liniami. NastÄ™pnie wypeÅ‚niany jest obszar miÄ™dzy tymi punktami.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Okno, w ktÃ³rym zostanie narysowany wypeÅ‚niony wielokÄ…t. </td></tr>
    <tr><td class="paramname">points</td><td>Wektor punktÃ³w, ktÃ³re definiujÄ… wierzchoÅ‚ki wielokÄ…ta. </td></tr>
    <tr><td class="paramname">fillColor</td><td>Kolor, ktÃ³rym zostanie wypeÅ‚niony obszar wewnÄ™trzny wielokÄ…ta.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Funkcja sprawdza, czy liczba punktÃ³w wynosi co najmniej 3 (minimalna liczba wierzchoÅ‚kÃ³w dla wielokÄ…ta). JeÅ›li nie, funkcja nie wykonuje Å¼adnego rysowania. </dd>
<dd>
Algorytm dziaÅ‚a na zasadzie skanowania poziomych linii, gdzie dla kaÅ¼dej linii poziomej (o staÅ‚ej wartoÅ›ci <code>y</code>) obliczane sÄ… punkty przeciÄ™cia z krawÄ™dziami wielokÄ…ta. NastÄ™pnie obszar miÄ™dzy tymi punktami jest wypeÅ‚niany w zadanym kolorze. </dd></dl>

</div>
</div>
<a id="a77cdbaff8f382917432a443a9a9a5e7f" name="a77cdbaff8f382917432a443a9a9a5e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77cdbaff8f382917432a443a9a9a5e7f">&#9670;&#160;</a></span>drawLineBasic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrimitiveRenderer::drawLineBasic </td>
          <td>(</td>
          <td class="paramtype">sf::RenderWindow &amp;</td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Color</td>          <td class="paramname"><span class="paramname"><em>color</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rysuje liniê za pomoc¹ algorytmu podstawowego. </p>
<p>Rysuje liniÄ™ miÄ™dzy dwoma punktami za pomocÄ… podstawowego rysowania SFML.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Obiekt do rysowania (np. sf::RenderWindow). </td></tr>
    <tr><td class="paramname">p1</td><td>Punkt pocz¹tkowy linii. </td></tr>
    <tr><td class="paramname">p2</td><td>Punkt koñcowy linii. </td></tr>
    <tr><td class="paramname">color</td><td>Kolor linii.</td></tr>
    <tr><td class="paramname">window</td><td>Obiekt okna renderowania. </td></tr>
    <tr><td class="paramname">p1</td><td>Punkt poczÄ…tkowy linii. </td></tr>
    <tr><td class="paramname">p2</td><td>Punkt koÅ„cowy linii. </td></tr>
    <tr><td class="paramname">color</td><td>Kolor linii. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac91fbc53cf97e40dc3e8005533563ae4" name="ac91fbc53cf97e40dc3e8005533563ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91fbc53cf97e40dc3e8005533563ae4">&#9670;&#160;</a></span>drawLineIncremental()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrimitiveRenderer::drawLineIncremental </td>
          <td>(</td>
          <td class="paramtype">sf::RenderTarget &amp;</td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_point2_d.html">Point2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Color</td>          <td class="paramname"><span class="paramname"><em>color</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rysuje liniê metod¹ przyrostow¹. </p>
<p>Rysuje liniÄ™ miÄ™dzy dwoma punktami za pomocÄ… algorytmu przyrostowego.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Obiekt do rysowania (np. sf::RenderTarget). </td></tr>
    <tr><td class="paramname">p1</td><td>Punkt pocz¹tkowy linii. </td></tr>
    <tr><td class="paramname">p2</td><td>Punkt koñcowy linii. </td></tr>
    <tr><td class="paramname">color</td><td>Kolor linii.</td></tr>
    <tr><td class="paramname">window</td><td>Obiekt okna renderowania. </td></tr>
    <tr><td class="paramname">p1</td><td>Punkt poczÄ…tkowy linii. </td></tr>
    <tr><td class="paramname">p2</td><td>Punkt koÅ„cowy linii. </td></tr>
    <tr><td class="paramname">color</td><td>Kolor linii. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a115646f1290e839e5e7097e4c76dff50" name="a115646f1290e839e5e7097e4c76dff50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115646f1290e839e5e7097e4c76dff50">&#9670;&#160;</a></span>drawPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PrimitiveRenderer::drawPolygon </td>
          <td>(</td>
          <td class="paramtype">sf::RenderWindow &amp;</td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_point2_d.html">Point2D</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Color</td>          <td class="paramname"><span class="paramname"><em>color</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>closed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rysuje wielok¹t. </p>
<p>Rysuje wielokÄ…t na podstawie podanych punktÃ³w.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Obiekt do rysowania (np. sf::RenderWindow). </td></tr>
    <tr><td class="paramname">points</td><td>Wektor punktów definiuj¹cych wielok¹t. </td></tr>
    <tr><td class="paramname">color</td><td>Kolor wielok¹ta. </td></tr>
    <tr><td class="paramname">closed</td><td>Okreœla, czy wielok¹t jest zamkniêty (domyœlnie true). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, jeœli wielok¹t zosta³ narysowany; false w przypadku b³êdu.</dd></dl>
<p>Funkcja rysuje wielokÄ…t na podstawie wektora punktÃ³w, Å‚Ä…czÄ…c je odcinkami. Opcjonalnie zamyka wielokÄ…t, Å‚Ä…czÄ…c ostatni punkt z pierwszym. W przypadku wykrycia przecinajÄ…cych siÄ™ odcinkÃ³w wielokÄ…t nie zostanie narysowany.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Obiekt okna renderowania. </td></tr>
    <tr><td class="paramname">points</td><td>Wektor punktÃ³w definiujÄ…cych wierzchoÅ‚ki wielokÄ…ta. </td></tr>
    <tr><td class="paramname">color</td><td>Kolor odcinkÃ³w wielokÄ…ta. </td></tr>
    <tr><td class="paramname">closed</td><td>Flaga okreÅ›lajÄ…ca, czy wielokÄ…t powinien byÄ‡ zamkniÄ™ty (ostatni punkt poÅ‚Ä…czony z pierwszym).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true JeÅ›li wielokÄ…t zostaÅ‚ poprawnie narysowany. </dd>
<dd>
false JeÅ›li podano mniej niÅ¼ dwa punkty lub wykryto przecinajÄ…ce siÄ™ odcinki. </dd></dl>

</div>
</div>
<a id="aa4db6ccc3a13a45faac4ccd03be56598" name="aa4db6ccc3a13a45faac4ccd03be56598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4db6ccc3a13a45faac4ccd03be56598">&#9670;&#160;</a></span>drawPolyline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrimitiveRenderer::drawPolyline </td>
          <td>(</td>
          <td class="paramtype">sf::RenderWindow &amp;</td>          <td class="paramname"><span class="paramname"><em>window</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_point2_d.html">Point2D</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Color</td>          <td class="paramname"><span class="paramname"><em>color</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>closed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rysuje wieloliniê (polyline). </p>
<p>Rysuje poliliniÄ™ Å‚Ä…czÄ…cÄ… zestaw punktÃ³w.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window</td><td>Obiekt do rysowania (np. sf::RenderWindow). </td></tr>
    <tr><td class="paramname">points</td><td>Wektor punktów definiuj¹cych wieloliniê. </td></tr>
    <tr><td class="paramname">color</td><td>Kolor wielolinii. </td></tr>
    <tr><td class="paramname">closed</td><td>Okreœla, czy wielolinia jest zamkniêta (domyœlnie false).</td></tr>
    <tr><td class="paramname">window</td><td>Obiekt okna renderowania. </td></tr>
    <tr><td class="paramname">points</td><td>Wektor punktÃ³w definiujÄ…cych poliliniÄ™. </td></tr>
    <tr><td class="paramname">color</td><td>Kolor linii. </td></tr>
    <tr><td class="paramname">closed</td><td>JeÅ›li true, rysuje zamkniÄ™tÄ… poliliniÄ™. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f37978f4a14baa3c20564a59bc9c502" name="a8f37978f4a14baa3c20564a59bc9c502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f37978f4a14baa3c20564a59bc9c502">&#9670;&#160;</a></span>floodFill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PrimitiveRenderer::floodFill </td>
          <td>(</td>
          <td class="paramtype">sf::RenderTexture &amp;</td>          <td class="paramname"><span class="paramname"><em>renderTexture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>startY</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Color</td>          <td class="paramname"><span class="paramname"><em>fillColor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Color</td>          <td class="paramname"><span class="paramname"><em>oldColor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wype³nianie obszaru metod¹ zalewania (flood fill). </p>
<p>WypeÅ‚nia obszar kolorem na podstawie algorytmu flood-fill.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderTexture</td><td>Tekstura do renderowania. </td></tr>
    <tr><td class="paramname">startX</td><td>Pozycja pocz¹tkowa w osi X. </td></tr>
    <tr><td class="paramname">startY</td><td>Pozycja pocz¹tkowa w osi Y. </td></tr>
    <tr><td class="paramname">fillColor</td><td>Kolor wype³nienia. </td></tr>
    <tr><td class="paramname">oldColor</td><td>Kolor pocz¹tkowy obszaru do wype³nienia.</td></tr>
  </table>
  </dd>
</dl>
<p>Funkcja wykonuje algorytm wypeÅ‚niania obszaru (ang. flood-fill), zaczynajÄ…c od punktu poczÄ…tkowego. WypeÅ‚nia wszystkie sÄ…siadujÄ…ce piksele o tym samym kolorze co <code>oldColor</code>, zmieniajÄ…c je na <code>fillColor</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderTexture</td><td>Obiekt <code>sf::RenderTexture</code>, w ktÃ³rym przeprowadzane jest wypeÅ‚nianie. </td></tr>
    <tr><td class="paramname">startX</td><td>WspÃ³Å‚rzÄ™dna X punktu poczÄ…tkowego. </td></tr>
    <tr><td class="paramname">startY</td><td>WspÃ³Å‚rzÄ™dna Y punktu poczÄ…tkowego. </td></tr>
    <tr><td class="paramname">fillColor</td><td>Kolor, ktÃ³rym wypeÅ‚niany jest obszar. </td></tr>
    <tr><td class="paramname">oldColor</td><td>Kolor pierwotny, ktÃ³ry ma zostaÄ‡ zastÄ…piony kolorem <code>fillColor</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Funkcja zakÅ‚ada, Å¼e punkt poczÄ…tkowy ma kolor rÃ³wny <code>oldColor</code>. JeÅ›li <code>fillColor</code> i <code>oldColor</code> sÄ… takie same, funkcja nic nie zmieni. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/Silnik_nowy/Silnik2D_new/<a class="el" href="_primitive_renderer_8h_source.html">PrimitiveRenderer.h</a></li>
<li>D:/Silnik_nowy/Silnik2D_new/<a class="el" href="_primitive_renderer_8cpp.html">PrimitiveRenderer.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
